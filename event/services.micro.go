// Code generated by protoc-gen-micro. DO NOT EDIT.
// source: event/services.proto

package event

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import common "gitlab.bull-b.com/aua/aua-proto/common"

import (
	client "github.com/micro/go-micro/client"
	server "github.com/micro/go-micro/server"
	context "context"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = common.Empty{}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ client.Option
var _ server.Option

// Client API for State service

type StateService interface {
	//  gateway login
	Login(ctx context.Context, in *LoginReq, opts ...client.CallOption) (*common.Empty, error)
	//  gateway User connect
	Connect(ctx context.Context, in *Session, opts ...client.CallOption) (*ConnectRsp, error)
	//  gateway connect
	GWStart(ctx context.Context, in *GWInfo, opts ...client.CallOption) (*common.Empty, error)
	//  gateway disconnect
	GWShutdown(ctx context.Context, in *GWInfo, opts ...client.CallOption) (*common.Empty, error)
}

type stateService struct {
	c    client.Client
	name string
}

func NewStateService(name string, c client.Client) StateService {
	if c == nil {
		c = client.NewClient()
	}
	if len(name) == 0 {
		name = "event"
	}
	return &stateService{
		c:    c,
		name: name,
	}
}

func (c *stateService) Login(ctx context.Context, in *LoginReq, opts ...client.CallOption) (*common.Empty, error) {
	req := c.c.NewRequest(c.name, "State.Login", in)
	out := new(common.Empty)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stateService) Connect(ctx context.Context, in *Session, opts ...client.CallOption) (*ConnectRsp, error) {
	req := c.c.NewRequest(c.name, "State.Connect", in)
	out := new(ConnectRsp)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stateService) GWStart(ctx context.Context, in *GWInfo, opts ...client.CallOption) (*common.Empty, error) {
	req := c.c.NewRequest(c.name, "State.GWStart", in)
	out := new(common.Empty)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stateService) GWShutdown(ctx context.Context, in *GWInfo, opts ...client.CallOption) (*common.Empty, error) {
	req := c.c.NewRequest(c.name, "State.GWShutdown", in)
	out := new(common.Empty)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for State service

type StateHandler interface {
	//  gateway login
	Login(context.Context, *LoginReq, *common.Empty) error
	//  gateway User connect
	Connect(context.Context, *Session, *ConnectRsp) error
	//  gateway connect
	GWStart(context.Context, *GWInfo, *common.Empty) error
	//  gateway disconnect
	GWShutdown(context.Context, *GWInfo, *common.Empty) error
}

func RegisterStateHandler(s server.Server, hdlr StateHandler, opts ...server.HandlerOption) error {
	type state interface {
		Login(ctx context.Context, in *LoginReq, out *common.Empty) error
		Connect(ctx context.Context, in *Session, out *ConnectRsp) error
		GWStart(ctx context.Context, in *GWInfo, out *common.Empty) error
		GWShutdown(ctx context.Context, in *GWInfo, out *common.Empty) error
	}
	type State struct {
		state
	}
	h := &stateHandler{hdlr}
	return s.Handle(s.NewHandler(&State{h}, opts...))
}

type stateHandler struct {
	StateHandler
}

func (h *stateHandler) Login(ctx context.Context, in *LoginReq, out *common.Empty) error {
	return h.StateHandler.Login(ctx, in, out)
}

func (h *stateHandler) Connect(ctx context.Context, in *Session, out *ConnectRsp) error {
	return h.StateHandler.Connect(ctx, in, out)
}

func (h *stateHandler) GWStart(ctx context.Context, in *GWInfo, out *common.Empty) error {
	return h.StateHandler.GWStart(ctx, in, out)
}

func (h *stateHandler) GWShutdown(ctx context.Context, in *GWInfo, out *common.Empty) error {
	return h.StateHandler.GWShutdown(ctx, in, out)
}
